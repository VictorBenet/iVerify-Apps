import { Controller, UseGuards, Post, Get, Body, BadRequestException, NotFoundException, BadGatewayException, Inject, forwardRef } from '@nestjs/common';
import { LoginUserDto } from './dto/loginUser.dto';
import { AuthService } from './auth.service';
import { ApiTags, ApiBearerAuth } from '@nestjs/swagger';
import { UsersService } from '../users/users.service';
import { InfoLogger } from '../logger/info-logger.service';
import { TokenGenerationDto } from './dto/TokenGeneration.dto';
import { RefreshTokenAuthGuard } from '../guards/RefreshToken-auth.guard';
import { LocalAuthGuard } from '../guards/Local-auth.guard';
import { WordpressAuthGuard } from '../guards/Wordpress-auth.guard';
import { userMessages } from '../../constant/messages';
import { isEmpty } from 'lodash';
import { catchError } from 'rxjs/operators';
import { environment } from '../../environments/environment';
@ApiTags('auth')
@Controller('auth')
export class AuthController {
    constructor(
        private readonly authService: AuthService,
        @Inject(forwardRef(() => UsersService))
        private readonly usersService: UsersService, 
        private InfoLogger: InfoLogger) {
        this.InfoLogger.setContext('AuthController');
    }

    @Post('login')
    @UseGuards(LocalAuthGuard)
    public async login(@Body() login: LoginUserDto) {
        const userData = await this.usersService.findByEmail(login.email);
        if (!userData) {
            this.InfoLogger.error(userMessages.userNotFound);
            throw new NotFoundException(userMessages.userNotFound);
        } else {
            const token = await this.authService.createToken(userData);
            if (!token) throw new BadGatewayException();
            this.InfoLogger.log('Token Generated');
            return {token, userData};
        }
    }

    @Get('wordpress')
    @UseGuards(WordpressAuthGuard)
    samlLogin() {
    
    }

    @Post('callback')
    async callback(@Body() query: any) {
        if (!isEmpty(query.code)) {
           const result = await this.authService.createTokenByCode(query.code)
           .pipe(
           catchError((error) => {
               console.log(error);
               throw new error; 
           })).toPromise();
            if (result.access_token && result.refresh_token) {
                /* Find and create */
                const wpUserData = await this.authService.getUserByData(result.access_token).toPromise();
                if (wpUserData) {
                    let userPostBody = {
                        "firstName": wpUserData.user_nicename,
                        "lastName": wpUserData.display_name,
                        "email": wpUserData.user_email,
                        "password": environment.WPPassword,
                        "roles": [{name: "admin"}],
                        "phone":"",
                        "address":""
                    };
                    let userData = await this.usersService.findOrRegister(userPostBody, null);
                    const token = await this.authService.createToken(userData);
                        if (!token) throw new BadGatewayException();
                    this.InfoLogger.log('Token Generated by auth code');
                    return {token, userData};
                }
            } else {
                throw new BadGatewayException(); 
            }
        }
    }
    
    @Post('generateToken')
    @ApiBearerAuth()
    @UseGuards(RefreshTokenAuthGuard)
    public async generateToken(@Body() userData: TokenGenerationDto) {
        return await this.usersService.findOne(userData.email).then(user => {
            if (!user) {
                this.InfoLogger.error(userMessages.userNotFound);
                throw new BadRequestException(userMessages.userNotFound);
            } else {
                const token = this.authService.createToken(user);
                if (!token) throw new BadGatewayException();
                this.InfoLogger.log('Token Generated');
                return token;
            }
        });
    }
}